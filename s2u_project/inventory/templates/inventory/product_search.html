{% extends "inventory/base.html" %}

{% block title %}Inventory Lookup ¬∑ S2U Operations{% endblock %}

{% block extra_head %}
<style>
  /* Toolbar below navbar, matching brand blue */
  .search-toolbar { background: var(--brand-navy); color: #fff; }
  .search-toolbar .title { font-weight: 700; margin: 0; }
  .search-shell { flex: 1 1 auto; min-width: 340px; }
  .search-shell .input-group { max-width: 760px; }
  @media (max-width: 992px) { .search-shell .input-group { max-width: 100%; } }

  /* Suggestions + list styling */
  .suggestion-box { position: absolute; top: calc(100% + 0.5rem); left: 0; right: 0; z-index: 30; max-height: 320px; overflow-y: auto; }
  .suggestion-box.hidden { display: none; }
  /* Make suggestions fully opaque so background doesn't bleed through */
  .suggestion-box .list-group { background:#fff; border:1px solid #e5e7eb; border-radius:12px; overflow:hidden; box-shadow:0 16px 40px -20px rgba(0,0,0,.25); }
  .suggestion-box .list-group-item { background:#fff; border-color:#eef2f7; }
  .suggestion-box .list-group-item.active,
  .suggestion-box .list-group-item:focus,
  .suggestion-box .list-group-item:hover {
    background-color: rgba(229,73,46,.08); /* subtle orange wash for hover/active */
    border-color: var(--brand-orange);
    color: var(--bs-body-color); /* keep text dark, avoid white on active */
    box-shadow: inset 3px 0 0 0 var(--brand-orange);
    transition: background-color .12s ease, border-color .12s ease;
  }

  /* Ensure default text color on items (overrides Bootstrap active color) */
  .suggestion-box .list-group-item { color: var(--bs-body-color); }
  .suggestion-box .list-group-item .small { color: var(--bs-secondary-color); }

  /* Results layout polish */
  .results-card { border: none; border-radius: 12px; box-shadow: 0 16px 40px -28px rgba(0,0,0,.25); }
  .table thead th { white-space: nowrap; text-transform: uppercase; font-size: .75rem; letter-spacing: .05em; }
  .table tbody td, .table tbody th { vertical-align: middle; font-size: .95rem; }

  /* Refresh button hover: use brand orange, not solid fill */
  .search-toolbar .btn-outline-light:hover,
  .search-toolbar .btn-outline-light:focus-visible {
    background-color: rgba(229,73,46,.12); /* subtle orange wash */
    border-color: var(--brand-orange);
    color: var(--brand-orange);
  }
</style>
{% endblock %}

{% block content %}
<section class="search-toolbar py-3">
  <div class="container-xl d-flex flex-wrap align-items-center gap-3">
    <h1 class="h5 title">Inventory Lookup</h1>
    <form id="search-form" autocomplete="off" class="d-flex align-items-start gap-2 flex-grow-1">
      <div class="search-shell position-relative">
        <label for="query" class="visually-hidden">Search Products</label>
        <div class="input-group input-group-lg shadow-sm">
          <span class="input-group-text bg-white border-end-0"><i class="bi bi-upc-scan"></i></span>
          <input type="text" id="query" name="q" value="{{ query }}" class="form-control border-start-0" placeholder="e.g. 085592157158 or Tito's" aria-label="Search products by name or barcode">
        </div>
        <div id="suggestion-box" class="suggestion-box hidden">
          <div class="list-group shadow" id="suggestion-list"></div>
        </div>
      </div>
      <button id="refresh-stock" type="button" class="btn btn-outline-light">
        <span class="spinner-border spinner-border-sm me-2 d-none" role="status" aria-hidden="true"></span>
        <i class="bi bi-arrow-clockwise me-1"></i>Refresh Stock & Monthly
      </button>
    </form>
  </div>
 </section>

<div class="container-xl py-4 py-lg-5">
  <div class="row justify-content-center">
    <div class="col-12 col-xl-10">
      <div id="feedback" class="alert alert-light border-0 results-card" role="alert">
        <i class="bi bi-info-circle me-2 text-primary"></i>
        Start typing or scan a barcode to see matching products.
      </div>

      <div class="selected-container mt-4">
        <div class="card results-card">
          <div class="card-header bg-white border-0">
            <h2 class="h6 mb-0"><i class="bi bi-grid-3x3-gap me-2 text-primary"></i>Selected Products</h2>
          </div>
          <div class="card-body p-0">
            <div class="table-responsive">
          <table class="table table-striped align-middle d-none" id="selected-table">
            <thead class="table-light">
              <tr>
                <th scope="col">#</th>
                <th scope="col">Product Name</th>
                <th scope="col">Barcode</th>
                <th scope="col">Supplier</th>
                {% for store in stores %}
                <th scope="col" class="text-center" title="{{ store.name }}">{{ store.number }}</th>
                {% endfor %}
                <th scope="col" class="text-center">Remove</th>
              </tr>
            </thead>
            <tbody id="selected-list"></tbody>
          </table>
            </div>
            <div class="p-3">
              <p id="selected-empty" class="empty m-0">
                <i class="bi bi-bag"></i> <span>Start typing or scan a barcode to add products.</span>
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script id="stores-data" type="application/json">{{ store_data_json|safe }}</script>
{% endblock %}

{% block extra_scripts %}
<script>
(function() {
    const input = document.getElementById('query');
    const form = document.getElementById('search-form');
    const feedback = document.getElementById('feedback');
    const suggestionBox = document.getElementById('suggestion-box');
    const suggestionList = document.getElementById('suggestion-list');
    const selectedTable = document.getElementById('selected-table');
    const selectedList = document.getElementById('selected-list');
    const selectedEmpty = document.getElementById('selected-empty');
    const stores = JSON.parse(document.getElementById('stores-data').textContent);
    const refreshButton = document.getElementById('refresh-stock');
    const refreshSpinner = refreshButton.querySelector('.spinner-border');

    let debounceTimer = null;
    let lastQuery = input.value.trim();
    let suggestionsData = [];
    let suggPage = 1, suggHasNext = false, suggQuery = '';
    let highlighted = -1;
    let selectedProducts = new Map();
    let tooltipInstances = [];
    let isProcessing = false;  // Prevent concurrent adds

    // Scanner auto-finish configuration and state
    const SCAN = { MIN_LEN: 6, IDLE_MS: 120, DUP_MS: 350 };
    let scanIdleTimer = null;
    let lastScanSubmit = { value: '', until: 0 };

    function escapeAttr(value) {
        return (value || '')
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

    function formatQuantity(value) {
        const numeric = value || value === 0 ? Number(value) : 0;
        return numeric.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        });
    }

    function refreshTooltips() {
        tooltipInstances.forEach((instance) => instance.dispose());
        tooltipInstances = Array.from(document.querySelectorAll('[data-bs-toggle="tooltip"]')).map(
            (el) => new bootstrap.Tooltip(el)
        );
    }

    // Short beep feedback for barcode scans
    // Many browsers block audio until a user gesture. We create a single
    // AudioContext and "unlock" it on the first gesture (pointer or key).
    let __audio = { ctx: null, unlocked: false };
    function __ensureAudio() {
        try {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return false;
            if (!__audio.ctx) __audio.ctx = new Ctx();
            if (__audio.ctx.state === 'suspended') {
                // resume() returns a promise on some browsers
                const p = __audio.ctx.resume?.();
                if (p && typeof p.then === 'function') p.catch(() => {});
            }
            __audio.unlocked = true;
            return true;
        } catch (_) { return false; }
    }
    // Unlock on first real interaction
    document.addEventListener('pointerdown', __ensureAudio, { once: true });
    document.addEventListener('keydown', (e) => { if (!e.isComposing) __ensureAudio(); }, { once: true });

    function playBeep(ok = true) {
        try {
            if (!__ensureAudio()) return; // No WebAudio or blocked
            const ctx = __audio.ctx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = ok ? 880 : 220; // high=success, low=error
            osc.connect(gain); gain.connect(ctx.destination);
            const now = ctx.currentTime;
            const dur = ok ? 0.09 : 0.18;
            const peak = ok ? 0.14 : 0.18; // slightly louder
            gain.gain.setValueAtTime(0.0001, now);
            gain.gain.linearRampToValueAtTime(peak, now + 0.006);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
            osc.start(now);
            osc.stop(now + dur + 0.02);
        } catch (_) {}
    }

    async function quickPickAndAddSearch(raw) {
        const query = (raw || '').trim();
        if (!query) return;
        try {
            const resp = await fetch(`{% url 'inventory:product_search_api' %}?q=${encodeURIComponent(query)}&page=1&page_size=10`);
            if (!resp.ok) throw new Error('Search failed');
            const data = await resp.json();
            const pool = [...(data.matches || []), ...(data.suggestions || [])];
            const isBarcode = /^\d{6,}$/.test(query);
            if (pool.length === 0) {
                feedback.innerHTML = `<i class=\"bi bi-exclamation-triangle me-1\"></i>No results for ‚Äú${query}‚Äù.`;
                if (isBarcode) playBeep(false);
                return;
            }
            const numeric = /^\d+$/.test(query) ? Number(query) : null;
            let chosen = pool.find(p => p.barcode && p.barcode === query);
            if (!chosen && numeric !== null) {
                chosen = pool.find(p => p.number === numeric) || null;
            }
            if (!chosen) chosen = pool[0];
            await addProduct(chosen);
            if (isBarcode) playBeep(true);
            input.value = '';
            lastQuery = '';
            hideSuggestions();
            try { input.focus(); } catch (_) {}
        } catch (e) {
            feedback.innerHTML = `<i class=\"bi bi-exclamation-octagon text-danger me-1\"></i>${e.message || 'Unable to add product'}`;
        }
    }

    function scheduleScanFinish() {
        const v = (input.value || '').trim();
        // Treat as a scan only if it looks like a numeric barcode.
        // This prevents regular typed names (e.g. "buffalotrace") from auto-adding.
        if (!/^\d{6,}$/.test(v)) return;
        if (scanIdleTimer) clearTimeout(scanIdleTimer);
        scanIdleTimer = setTimeout(async () => {
            const now = Date.now();
            if (lastScanSubmit.value === v && now < lastScanSubmit.until) return; // duplicate guard
            lastScanSubmit = { value: v, until: now + SCAN.DUP_MS };
            await quickPickAndAddSearch(v);
        }, SCAN.IDLE_MS);
    }

    // Fetch monthly sales for a product (async, non-blocking)
    async function fetchMonthlySales(productNumber, forceRefresh = false) {
        try {
            const url = new URL(`{% url 'inventory:monthly_sales_api' %}`, window.location.origin);
            url.searchParams.set('product', productNumber);
            if (forceRefresh) url.searchParams.set('force', '1');

            console.log(`[Inventory] Fetching monthly sales for product ${productNumber}...`);
            const response = await fetch(url);
            if (!response.ok) {
                console.warn(`[Inventory] Monthly sales API returned ${response.status} for product ${productNumber}`);
                return;
            }

            const data = await response.json();
            console.log(`[Inventory] Monthly sales data for product ${productNumber}:`, data);

            const key = String(productNumber);
            const product = selectedProducts.get(key);
            if (!product) {
                console.warn(`[Inventory] Product ${productNumber} not found in selectedProducts`);
                return;
            }

            // Update monthly sales
            product.monthly_sales = data.sales || {};
            selectedProducts.set(key, product);
            console.log(`[Inventory] Updated product ${productNumber} with monthly_sales:`, product.monthly_sales);
            renderSelected();
        } catch (error) {
            console.error(`[Inventory] Failed to fetch monthly sales for product ${productNumber}:`, error);
        }
    }

    function renderSelected() {
        if (selectedProducts.size === 0) {
            selectedTable.classList.add('d-none');
            selectedList.innerHTML = '';
            selectedEmpty.style.display = 'block';
            refreshTooltips();
            return;
        }

        selectedEmpty.style.display = 'none';
        selectedTable.classList.remove('d-none');

        selectedList.innerHTML = Array.from(selectedProducts.values()).map((product) => {
            const stockMap = new Map(
                Array.isArray(product.stocks)
                    ? product.stocks.map((entry) => [entry.store.id, entry])
                    : []
            );

            const monthlySalesMap = product.monthly_sales || {};

            const storeCells = stores.map((store) => {
                const entry = stockMap.get(store.id);
                const actual = formatQuantity(entry?.stock?.actual ?? 0);
                const listed = entry?.stock?.listed;
                const badge = listed
                    ? ' <span class="badge bg-success-subtle text-success">Listed</span>'
                    : '';
                const cached = entry?.cached ? ' <span class="badge bg-warning-subtle text-warning" title="Cached data">üì¶</span>' : '';
                const monthlySales = monthlySalesMap[store.id] || 0;
                const salesDisplay = monthlySales > 0 ? `<div class="small text-primary fw-semibold">${monthlySales}/mo</div>` : '';
                return `<td class="text-center" data-bs-toggle="tooltip" data-bs-placement="top" title="${escapeAttr(store.name)}"><div>${actual}${badge}${cached}</div>${salesDisplay}</td>`;
            }).join('');

            return `
                <tr>
                    <th scope="row" class="align-middle">${product.number}</th>
                    <td class="align-middle">${product.name}</td>
                    <td class="align-middle">
                        ${(() => {
                            const arr = Array.isArray(product.barcodes) ? product.barcodes : (product.barcode ? [product.barcode] : []);
                            if (!arr.length) return '‚Äî';
                            return arr.map(c => `<div class="small text-muted">${c}</div>`).join('');
                        })()}
                    </td>
                    <td class="align-middle">${product.supplier_name || '‚Äî'}</td>
                    ${storeCells}
                    <td class="text-center align-middle">
                        <button type="button" class="btn btn-outline-danger btn-sm remove-product" data-number="${product.number}">
                            <i class="bi bi-trash"></i>
                        </button>
                    </td>
                </tr>
            `;
        }).join('');

        refreshTooltips();
    }

    function hideSuggestions() {
        suggestionBox.classList.add('hidden');
        suggestionList.innerHTML = '';
        suggestionsData = [];
        highlighted = -1;
    }

    function highlight(index) {
        highlighted = index;
        const items = suggestionList.querySelectorAll('.list-group-item');
        items.forEach((item, idx) => {
            if (idx === highlighted) {
                item.classList.add('active');
                item.scrollIntoView({ block: 'nearest' });
            } else {
                item.classList.remove('active');
            }
        });
    }

    function renderSuggestions(query, matches, suggestions, append = false, hasNext = false) {
        const combined = [...(matches || []), ...(suggestions || [])];
        highlighted = -1;
        if (!append) suggestionsData = [];
        if (!query || (combined.length === 0 && !append)) {
            hideSuggestions();
            feedback.innerHTML = query
                ? `<i class="bi bi-exclamation-triangle me-1"></i>No results found for ‚Äú${query}‚Äù.`
                : `<i class="bi bi-info-circle me-1"></i>Start typing or scan a barcode to see matching products.`;
            // If the input looks like a barcode (6+ digits), play a low beep on no results
            try { if (/^\d{6,}$/.test(query)) playBeep(false); } catch (_) {}
            return;
        }
        const start = suggestionsData.length;
        suggestionsData.push(...combined);
        suggestionList.innerHTML = suggestionsData.map((product, index) => `
            <button type="button" class="list-group-item list-group-item-action" data-index="${index}">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <div class="fw-semibold">
                            <i class="bi bi-tag me-2 text-primary"></i>${product.name}
                        </div>
                        <div class="small text-muted">
                            <i class="bi bi-hash me-1"></i>${product.number}
                            <span class="mx-2">‚Ä¢</span>
                            <i class="bi bi-upc me-1"></i>${product.barcode || '‚Äî'}
                            <span class="mx-2">‚Ä¢</span>
                            <i class="bi bi-truck me-1"></i>${product.supplier_name || '‚Äî'}
                        </div>
                    </div>
                    <i class="bi bi-arrow-return-right text-primary fs-5"></i>
                </div>
            </button>
        `).join('');
        // Load more
        suggHasNext = !!hasNext;
        if (suggHasNext) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'list-group-item list-group-item-action text-center fw-semibold';
            btn.dataset.loadmore = '1';
            btn.innerHTML = '<i class="bi bi-plus-circle me-1"></i>Load more';
            suggestionList.appendChild(btn);
        }
        suggestionBox.classList.remove('hidden');
        feedback.innerHTML = `<i class="bi bi-list-ul me-1"></i>Showing ${suggestionsData.length} result${suggestionsData.length === 1 ? '' : 's'} for ‚Äú${query}‚Äù. Use ‚Üë ‚Üì and Enter to add.`;
    }

    async function fetchSuggestions(query, page = 1, append = false) {
        if (!query) {
            hideSuggestions();
            feedback.innerHTML = `<i class="bi bi-info-circle me-1"></i>Start typing or scan a barcode to see matching products.`;
            return;
        }

        lastQuery = query;
        suggQuery = query;
        suggPage = page;
        try {
            const response = await fetch(`{% url 'inventory:product_search_api' %}?q=${encodeURIComponent(query)}&page=${page}&page_size=10`);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            const data = await response.json();
            if (lastQuery !== query) {
                return;
            }

            renderSuggestions(query, data.matches, data.suggestions, append, !!data.has_next);
        } catch (error) {
            hideSuggestions();
            feedback.innerHTML = `<i class="bi bi-wifi-off me-1"></i>Unable to fetch suggestions right now. Please try again.`;
        }
    }

    async function fetchProductStock(productNumber, forceRefresh = false) {
        const url = `{% url 'inventory:product_stock_api' %}?product=${productNumber}${forceRefresh ? '&force=1' : ''}`;
        const response = await fetch(url);
        if (!response.ok) {
            let message = 'Unable to fetch stock.';
            try {
                const data = await response.json();
                if (data && data.error) {
                    message = data.error;
                }
            } catch (_) {
                message = 'Unable to fetch stock.';
            }
            throw new Error(message);
        }
        const payload = await response.json();
        if (payload.error) {
            throw new Error(payload.error);
        }
        return payload;
    }

    function getCsrfToken() {
        const input = document.querySelector('input[name="csrfmiddlewaretoken"]');
        if (input && input.value) return input.value;
        const cookie = document.cookie.split('; ').find(row => row.startsWith('csrftoken='));
        return cookie ? cookie.split('=')[1] : '';
    }

    async function startProductJob(productNumber) {
        const res = await fetch(`{% url 'inventory:product_refresh_single_start' 0 %}`.replace('/0/', `/${productNumber}/`), {
            method: 'POST',
            headers: { 'X-CSRFToken': getCsrfToken() }
        });
        if (res.status === 409) return { queued: false, conflict: true };
        const data = await res.json();
        if (!data.ok) throw new Error(data.error || 'Failed to start job');
        return { job: data.job };
    }

    async function pollProductJob(job) {
        const url = new URL(`{% url 'inventory:product_refresh_single_status' %}`, window.location.origin);
        url.searchParams.set('job', job);
        const res = await fetch(url.toString());
        const data = await res.json();
        if (!data.ok) throw new Error(data.error || 'status');
        return data;
    }

    async function refreshAllProductsStock() {
        if (selectedProducts.size === 0) {
            feedback.innerHTML = `<i class="bi bi-info-circle me-1"></i>No products to refresh. Add products first.`;
            return;
        }

        const productsArray = Array.from(selectedProducts.values());
        let started = 0, completed = 0, conflicts = 0;
        feedback.innerHTML = `<i class="bi bi-arrow-clockwise text-primary me-1"></i>Queuing ${productsArray.length} product(s)‚Ä¶`;

        const jobs = await Promise.all(productsArray.map(async (p) => {
            try {
                const { job, conflict } = await startProductJob(p.number);
                if (conflict) { conflicts++; return null; }
                started++; return { number: p.number, job };
            } catch (e) { return null; }
        }));

        feedback.innerHTML = `<i class=\"bi bi-arrow-repeat me-1\"></i>Refreshing‚Ä¶ 0/${productsArray.length} done`;

        // Poll all jobs; on completion, pull cached stock+monthly and update table
        await Promise.all(jobs.filter(Boolean).map(async (j) => {
            const job = j.job; const num = j.number;
            const poll = async () => {
                try {
                    const s = await pollProductJob(job);
                    if (s.done) {
                        // Pull cached stock
                        try {
                            const stockResp = await fetch(`{% url 'inventory:product_stock_api' %}?product=${num}`);
                            if (stockResp.ok) {
                                const stock = await stockResp.json();
                                const existing = selectedProducts.get(String(num));
                                if (existing) {
                                    existing.stocks = stock.stocks || [];
                                    existing.barcodes = Array.isArray(stock.barcodes) ? stock.barcodes : (existing.barcodes || (existing.barcode ? [existing.barcode] : []));
                                    selectedProducts.set(String(num), existing);
                                }
                            }
                            await fetchMonthlySales(num, false);
                        } catch (_) {}
                        completed++;
                        renderSelected();
                        feedback.innerHTML = `<i class=\"bi bi-arrow-repeat me-1\"></i>Refreshing‚Ä¶ ${completed}/${productsArray.length} done`;
                    } else {
                        setTimeout(poll, 900);
                    }
                } catch (err) {
                    setTimeout(poll, 1200);
                }
            };
            await poll();
        }));

        const msg = conflicts > 0 ? ` (${conflicts} already running)` : '';
        feedback.innerHTML = `<i class=\"bi bi-check-circle text-success me-1\"></i>Refresh complete for ${completed}/${productsArray.length}${msg}.`;
    }

    async function addProduct(product) {
        if (!product) {
            return;
        }

        // Prevent concurrent additions
        if (isProcessing) {
            console.log('Already processing, skipping...');
            return;
        }

        const key = String(product.number);
        if (selectedProducts.has(key)) {
            hideSuggestions();
            input.value = '';
            lastQuery = '';
            feedback.innerHTML = `<i class="bi bi-info-circle text-secondary me-1"></i>Product already added.`;
            return;
        }

        isProcessing = true;
        feedback.innerHTML = `<i class="bi bi-arrow-clockwise text-primary me-1"></i>Checking stock for "${product.name}" across all stores...`;

        let stockEntries = [];
        let stockPayload = null;
        try {
            stockPayload = await fetchProductStock(product.number);
            if (Array.isArray(stockPayload?.stocks)) {
                stockEntries = stockPayload.stocks;
            }
        } catch (error) {
            feedback.innerHTML = `<i class="bi bi-exclamation-octagon text-danger me-1"></i>${error.message || 'Unable to retrieve stock. Try again.'}`;
            isProcessing = false;
            return;
        }

        const newData = {
            ...product,
            stocks: stockEntries,
            // prefer barcodes from stock payload; fallback to suggestion payload
            barcodes: Array.isArray(stockPayload?.barcodes)
                ? stockPayload.barcodes
                : (Array.isArray(product.barcodes) ? product.barcodes : (product.barcode ? [product.barcode] : [])),
            monthly_sales: {},
        };
        selectedProducts = new Map([[key, newData], ...selectedProducts]);

        renderSelected();
        hideSuggestions();
        input.value = '';
        lastQuery = '';
        isProcessing = false;

        if (stockEntries.length > 0) {
            const totalQty = stockEntries.reduce((sum, entry) => {
                const value = entry.stock?.actual;
                return sum + (value || value === 0 ? Number(value) : 0);
            }, 0);
            feedback.innerHTML = `<i class="bi bi-check-circle text-success me-1"></i>Added "${product.name}" ‚Ä¢ Total stock: ${formatQuantity(totalQty)} across ${stockEntries.length} store${stockEntries.length === 1 ? '' : 's'}.`;
        } else {
            feedback.innerHTML = `<i class="bi bi-info-circle text-secondary me-1"></i>Added "${product.name}", but no stock was reported.`;
        }

        // Fetch monthly sales in background (non-blocking)
        fetchMonthlySales(product.number);
    }

    suggestionList.addEventListener('mousedown', async (event) => {
        event.preventDefault();
        const more = event.target.closest('[data-loadmore="1"]');
        if (more && suggHasNext) {
            more.disabled = true;
            await fetchSuggestions(suggQuery, suggPage + 1, true);
            return;
        }
        const item = event.target.closest('.list-group-item[data-index]');
        if (!item) return;
        const index = Number(item.dataset.index);
        const product = suggestionsData[index];
        await addProduct(product);
    });

    selectedList.addEventListener('click', (event) => {
        const button = event.target.closest('.remove-product');
        if (!button) {
            return;
        }
        const key = button.dataset.number;
        if (selectedProducts.delete(key)) {
            renderSelected();
            feedback.innerHTML = `<i class="bi bi-trash text-danger me-1"></i>Removed product #${key} from the list.`;
        }
    });

    input.addEventListener('input', () => {
        const value = input.value.trim();
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => fetchSuggestions(value), 250);
        scheduleScanFinish();
    });

    input.addEventListener('paste', () => { setTimeout(scheduleScanFinish, 0); });

    input.addEventListener('keydown', async (event) => {
        // Some scanners send Tab instead of Enter ‚Äî treat Tab as submit for numeric barcodes
        if (event.key === 'Tab') {
            const v = input.value.trim();
            // Only auto-submit Tab when the value looks like a pure numeric barcode.
            if (/^\d{6,}$/.test(v)) {
                event.preventDefault();
                const now = Date.now();
                if (!(lastScanSubmit.value === v && now < lastScanSubmit.until)) {
                    lastScanSubmit = { value: v, until: now + SCAN.DUP_MS };
                    await quickPickAndAddSearch(v);
                }
                return;
            }
        }
        if (suggestionsData.length === 0) {
            if (event.key === 'Enter') {
                // Fallback for fast barcode scans: do a quick lookup and add
                event.preventDefault();
                const raw = input.value.trim();
                if (!raw) return;
                try {
                    const resp = await fetch(`{% url 'inventory:product_search_api' %}?q=${encodeURIComponent(raw)}&page=1&page_size=10`);
                    if (!resp.ok) throw new Error('Search failed');
                    const data = await resp.json();
                    const pool = [...(data.matches || []), ...(data.suggestions || [])];
                    const isBarcode = /^\d{6,}$/.test(raw);
                    if (pool.length === 0) {
                        feedback.innerHTML = `<i class=\"bi bi-exclamation-triangle me-1\"></i>No results for ‚Äú${raw}‚Äù.`;
                        if (isBarcode) playBeep(false);
                        return;
                    }
                    const numeric = /^\d+$/.test(raw) ? Number(raw) : null;
                    let chosen = pool.find(p => p.barcode && p.barcode === raw);
                    if (!chosen && numeric !== null) {
                        chosen = pool.find(p => p.number === numeric) || null;
                    }
                    if (isBarcode) {
                        if (chosen) {
                            await addProduct(chosen);
                            playBeep(true);
                        } else {
                            feedback.innerHTML = `<i class=\"bi bi-exclamation-triangle me-1\"></i>No exact barcode match for ‚Äú${raw}‚Äù.`;
                            playBeep(false);
                        }
                    } else {
                        if (!chosen) chosen = pool[0];
                        await addProduct(chosen);
                    }
                } catch (e) {
                    feedback.innerHTML = `<i class=\"bi bi-exclamation-octagon text-danger me-1\"></i>${e.message || 'Unable to add product'}`;
                }
            }
            return;
        }
        const maxIndex = suggestionsData.length - 1;
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            highlight(highlighted < maxIndex ? highlighted + 1 : 0);
        } else if (event.key === 'ArrowUp') {
            event.preventDefault();
            highlight(highlighted > 0 ? highlighted - 1 : maxIndex);
        } else if (event.key === 'Enter') {
            if (highlighted >= 0 && highlighted <= maxIndex) {
                event.preventDefault();
                await addProduct({ ...suggestionsData[highlighted] });
            }
        } else if (event.key === 'Escape') {
            hideSuggestions();
        }
    });

    document.addEventListener('click', (event) => {
        if (!suggestionBox.contains(event.target) && event.target !== input) {
            hideSuggestions();
        }
    });

    form.addEventListener('submit', (event) => {
        event.preventDefault();
        fetchSuggestions(input.value.trim());
    });

    refreshButton.addEventListener('click', async () => {
        refreshButton.disabled = true;
        refreshSpinner.classList.remove('d-none');

        try {
            await refreshAllProductsStock();
        } catch (error) {
            feedback.innerHTML = `<i class="bi bi-exclamation-octagon text-danger me-1"></i>Refresh failed: ${error.message}`;
        } finally {
            refreshSpinner.classList.add('d-none');
            refreshButton.disabled = false;
        }
    });

    if (input.value.trim()) {
        fetchSuggestions(input.value.trim());
    }

    renderSelected();
})();
</script>
{% endblock %}
